#include "cache.h"
#include <vector>

//Inspired by https://drive.google.com/file/d/1lKWpaRGaW8nKRBDs8X1y-4AiMWLUAGWO/view
// Designed by Alberto Ros
// Implemented by Guillaume Thivolet

typedef struct current_page_entry_t {
	bool accessed_cache_lines[64];
	uint64_t page;
} current_page_entry;

struct current_pages_table {
	vector<current_page_entry> entries;
} Curr_page_tab;

typedef struct previous_demand_request_t {
	uint64_t page_address;
	uint8_t cacheline_offset;
	uint8_t issueTime;
} Prev_demand_req;

typedef struct previous_prefetch_request_t {
	uint64_t page_address;
	uint8_t cacheline_offset;
	uint8_t issueTime;
	uint8_t completed_bit; //in this case, issueTime stores the time that the prefetch required to be resolved
} Prev_pref_req;

IT index_table[256];

vector<Prev_pref_req> prefetcher_requests;
vector<Prev_demand_req> demand_requests;

Curr_page_tab current_pages[512];

void CACHE::l2c_prefetcher_initialize() {
	//initialize ACL
}

uint32_t CACHE::l2c_prefetcher_operate(uint64_t addr, uint64_t ip, uint8_t cache_hit, uint8_t type, uint32_t metadata_in) {
	uint64_t page_addr = (addr >> LOG2_PAGE_SIZE);

	Prev_demand_request r = {};
	// only issue a prefetch if the prefetch address is in the same 4 KB page
	// as the current demand access address
	if ((pf_address >> LOG2_PAGE_SIZE) != (addr >> LOG2_PAGE_SIZE))
		break;

	return metadata_in;
}

uint32_t CACHE::l2c_prefetcher_cache_fill(uint64_t addr, uint32_t set, uint32_t way, uint8_t prefetch, uint64_t evicted_addr, uint32_t metadata_in) {

	if (prefetch) {
	}

	vector<> xx;

	for (size_t i = 0; i < previous_demand_requests.size(); i++) {
		for (size_t i = 0; i < 64; i++) {
			//if offset could have brought the cache line in a timely manner, according to the obtained latency
		}
	}

	return metadata_in;
}

void CACHE::l2c_prefetcher_final_stats() {
}
