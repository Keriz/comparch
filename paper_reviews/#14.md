==+== Computer Architecture Paper Review Form
==-== DO NOT CHANGE LINES THAT START WITH "==+==" UNLESS DIRECTED!
==-== For further guidance, or to upload this file when you are done, go to:
==-== https://safari.ethz.ch/review/architecture21/offline

==+== =====================================================================
==+== Begin Review
==+== Reviewer: Guillaume Thivolet <gthivolet@student.ethz.ch>

==+== Paper Number

14

==+== Review Readiness
==-== Enter "Ready" if the review is ready for others to see:

Ready

==+== A. Overall merit
==-== Choices:
==-==    1. Reject
==-==    2. Weak reject
==-==    3. Weak accept
==-==    4. Accept
==-==    5. Strong accept
==-== Enter the number of your choice:

4

==+== B. Reviewer expertise
==-== Choices:
==-==    1. No familiarity
==-==    2. Some familiarity
==-==    3. Knowledgeable
==-==    4. Expert
==-== Enter the number of your choice:

2

==+== C. Paper summary

GenASM is the first of its kind Approximate String Matching acceleration framework for genome sequence analysis. It expands the Bitap algorithm to support long reads, unrolls the algorithm for parallelism, and implements traceback for optimal alignment.

There are 3 main use cases for GenASM: read alignment, pre-alignment filtering and edit distance calculation.

GenASM consists of two dependent parts, GenASM-DC (distance calculation) and GenASN-TB (traceback). The former generates bitvectors from reads and accelerates the Bitap algorithm with the mentioned improvements while the latter uses the bitvectors generated by GenASM-DC to find the sequence of deletion, insertion, matches, substitution along with their positions. Both have been co-designed on a hardware accelerator leveraging data-locality, enabling a high degree of parallelism from independent computing units and utilizing HBM for a high-throughput.

The benchmarking shows that the tailored hardware and algorithm in GenASM outperform existing work in terms of throughput and speedup (~x5 compared to hardware baselines and orders of magnitude faster depending on settings for others). The power consumption is also greatly reduced if compared to processors or hardware baselines.

==+== D. Comments for author


# Strength

- Thorough and fair benchmarking on multiple use cases
- Divide and conquer approach and the co-design of the GenASN algo with the HW accelerator which leads to a high degree of parallelism
- Thorough and fair benchmarking on multiple use cases
- Support long reads
- Improves accuracy of pre-alignement filtering

# Weaknesses

- Partial support for more complex scoring schemes

This is a high-quality paper for Approximate String Matching in Genome Sequence Analysis. The Bitap algorithm used as a baseline is well introduced and the vectors of improvements are well described. The figures are helpful for readers understanding. Emphasis has been set on evaluating GenASM with existing work and comparing multiple baselines.

The downside is that GenASM is so versatile with a diversity of use cases that it could prove helpful to explicitely state what future work could be achieved, that which is almost not discussed here.

- (Figure 8. in the GenASM-DC block, at the far right it should be PE64 and not PE65)

==+== E. Comments for PC
==-== Hidden from authors.

==+== Scratchpad (for unsaved private notes)

Approximate String  Matching acceleration framewrok for genome sequence analysis
Goal is to design a fast, efficient, flexible framework for both short and long read
Bitap algorithm -> fast & simple bitwise operations to perform approximate tring matching

genasm based on bitap

two modifications 
->(support long reads, // single string matching operation by removing data dependencies)
-> implemented traceback to utilize info. collected ruring ASM for optimal alginemnt

hardware accelerated perfomance modeling

3 use for genASM: read aligneent, pre-alignement fiterring, edit distance calcualation)
100x + performance gain comp. to Minimap2 and BWA-MEM, power reduced by x34 forlong reads, similar for shortreads 

Bitmap limitations 
-> no support for long reads
-> data dependency between iterations
-> no support for traceback
-> limited compute parallelism
-> limited memroy bandwidth

gen asm dc
////
long read support, increase in te algorithm complexeity
loop unrolling
text/level parallelism

genasm TB
intermediate storage with gen asm dc /| divide and conquer approach to reduce memory footprint
partial support for complex scoring schemes

ANALYSIS

+++ main advantage comes from divide and conquer approach and the co-design of the GenASN algo with the hw accelearator
high degree of paralellelism
+++ thorough and fair benchmarking on multiple use cases
+++ Usage of HBM to raise throughput
another error type might lead to a bigger error later on

--- Partial support for more complex scoring schemes

==+== End Review
